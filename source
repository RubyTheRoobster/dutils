/*binom.d by Ruby The Roobster*/
/* Version 0.2.5 Release*/
/*Last Updated: 08/06/2021*/
/*Module for handling binomials in the D Programming Languge 2.0*/
module dutils.binom;

public class OutBinom(X)  if(is(X : real))	{ //Class for the output of functions involving binomials
	private:
	uint[] coefficiants;
	X[] outvals;
	X sum_of_outvals = 0;
	X x = 0;
	X y = 0;
	uint n = 0;
	public:
		this(const uint[] coefficant, const X[] outvals)	{
			this.coefficiants.length = coefficant.length;
			this.outvals.length = outvals.length;
			for(int i = 0; i < coefficant.length; i++)	{
				this.coefficiants[i] = coefficant[i];
			}

			for(int i = 0; i < outvals.length; i++)	{
				this.outvals[i] = outvals[i];
				this.sum_of_outvals += outvals[i];
			}
		}

		this(const uint[] coefficiant, const X[] outvals, const X x, const X y, const uint n)	{
			this.coefficiants.length = coefficiant.length;
			this.outvals.length = outvals.length;
			for(int i = 0; i < coefficiant.length; i++)	{
				this.coefficiants[i] = coefficiant[i];
			}

			for(int i = 0; i < outvals.length; i++)	{
				this.outvals[i] = outvals[i];
				this.sum_of_outvals += outvals[i];
			}

			this.x = x;
			this.y = y;
			this.n = n;
		}

		X result() @property	{
			return this.sum_of_outvals;
		}

		X[] seperatedvals() @property	{
			return this.outvals.dup;
		}

		uint[] coefficients()	@property	{
			return this.coefficiants.dup;
		}

		X xval() @property	{
			return this.x;
		}

		X yval() @property	{
			return this.y;
		}

		uint nval() @property	{
			return this.n;
		}	
}

public uint factorial(uint f)	{ //Bug Free
	if(f == 0 || f == 1)
		return 1;
	for(int x = f-1; x > 0; x--)	{
		f = f * x;
	}
	return f;
}
public class InBinom(X) if(is(X : real))	{	//Class for the binomials(input)
	private:
		X x;
		X y;
		uint n;
	public:
		this(X x, X y, uint n)	{
			this.x = x;
			this.y = y;
			this.n = n;
		}

		OutBinom!(typeof(this.x)) BinomEqu()	{ //Implements the Binomial Theorem
			uint[] coff;
			coff.length = this.n+1;
			X[] outval;
			outval.length = this.n+1;
			for(uint k = 0; k <= this.n;k++)	{
				coff[k] = (factorial(this.n));
				coff[k]  /= (factorial(this.n - k) * factorial(k));
				outval[k] = (coff[k] * ((this.x ^^ (this.n-k)) * (this.y ^^ (k))));
			}

			auto ret = new OutBinom!(typeof(this.x))(coff,outval);
			return ret;
		}
}/*skeleton.d by Ruby The Roobster*/
/*Version 1.0 Release*/
/*Module for representing skeletons in the D Programming Language 2.0*/

public struct Point	{ //Point structure...
	real x;
	real y;
	real z;
	void opAssign(Point rhs)	{
		this.x = rhs.x;
		this.y = rhs.y;
		this.z = rhs.z;
	}
	void opOpAssign(string op)(Point rhs)	{
		mixin("this.x " ~ op ~ "= rhs.x;");
		mixin("this.y " ~ op ~ "= rhs.y;");
		mixin("this.z " ~ op ~ "= rhs.z;");
	}
}

public struct Face	{ //Face(of a 3D shape) structure...
	Line[] lines;
	Point center;
	void opAssign(Face rhs)	{
		this.lines.length = rhs.lines.length;
		foreach(i;0 .. this.lines.length)	{
			this.lines[i] = rhs.lines[i];
		}
	}
}

public struct Skeleton	{ //Skeleton of a 3D structure...
	Face[] faces;
	Point center;
	void opAssign(Skeleton rhs)	{
		this.faces.length = rhs.faces.length;
		foreach(i;0 .. this.faces.length)	{
			this.faces[i] = rhs.faces[i];
		}
		this.center = rhs.center;
	}
}


public struct Line	{ //Line struct...
	Point[] mid_points;
	Point start;
	Point stop;
	void opAssign(Line rhs)	{
		this.start = rhs.start;
		this.stop = rhs.stop;
		this.mid_points.length = rhs.mid_points.length;
		foreach(i;0 .. this.mid_points.length)	{
			this.mid_points[i] = rhs.mid_points[i];
		}
	}
}
/*sprite.d by Ruby The Roobster*/
/*Version 0.3.5 Release*/
/*Last Update: 08/23/2021*/
/*Module for sprites in the D Programming Language 2.0*/
module dutils.sprite;
import skeleton : Point;

	public struct Color	{
		ubyte r = 0;
		ubyte g = 0;
		ubyte b = 0;
		ubyte a = 255;
		void opAssign(Color rhs)	{
			this.r = rhs.r;
			this.g = rhs.g;
			this.b = rhs.b;
			this.a = rhs.a;
		}
	}

	public struct Sprite	{
		Color[] colors;
		Point[][] points;
		invariant()	{
			assert(colors.length == points.length, "Assertion failure: Sprite.colors.length and Sprite.points.length must always be equal...");
		}
		void opAssign(Sprite rhs)	{
			this.colors.length = rhs.colors.length;
			this.points.length = rhs.points.length;
			foreach(i;0 .. this.colors.length)	{
				this.colors[i] = rhs.colors[i];
			}
			foreach(i;0 .. this.points.length)	{
				this.points[i].length = rhs.points[i].length;
				foreach(j;0 .. this.points[i].length)	{
					this.points[i][j] = rhs.points[i][j];
				}
			}
		}
		package void ChangeLengths(uint c)	{ //Change both lengths so invariant doesn't get triggered...
			this.colors.length = c;
			this.points.length = c;
		}
	}
	
	public Sprite ReadSpriteFromFile(immutable(char)[] filename)	{ //Reads a sprite in my made up .spr format(trash, why does this even exist)
		ubyte[] ftext;
		Color[] colors;
		Point[][] points;
		import std.file;
		uint i = 0;
		ftext = cast(ubyte[])read(filename);
		while(i < ftext.length)	{ //Parse the file...
			long main;
			short exp;
			uint x = 0;
			++colors.length;
			++points.length;
			colors[x].r = ftext[i]; //Set r color...
			++i;
			colors[x].g = ftext[i];
			++i;
			colors[x].b = ftext[i];
			++i;
			colors[x].a = ftext[i];
			++i;
			ubyte tempcolor = ftext[i];
			++i;
			long temp;
			for(ubyte j = 0;j < tempcolor; ++j)	{
				posfunc(ftext, main, exp, temp, i, j, points , x);
			}
		}
		return Sprite(colors, points);
	}
	
	package void posfunc(const ubyte[] ftext, ref long main, ref short exp, ref long temp, ref uint i, const ubyte j, ref Point[][] points, ref uint x)	{
		++points[x].length;
		foreach(z;0 .. 3)	{
			short shift = 56;
			main = ftext[i];
			main <<= shift;
			++i;
			shift -= 8;
			while(shift >= 0)	{
				temp = ftext[i];
				main = (main <= (-0)) ? (main - temp) : (main + temp);
				++i;
				shift -= 8;
			}
			exp = ftext[i];
			exp <<= 8;
			++i;
			exp += ftext[i];
			++i;
			switch(z)	{
				case 0:
					points[x][j].x = (main * 10^^exp);
					break;
				case 1:
					points[x][j].y = (main * 10^^exp);
					break;
				case 2:
					points[x][j].z = (main * 10^^exp);
					break;
				default:
					assert(false); //bruh...
			}
		}
	}